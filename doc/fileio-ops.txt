==============================================================================
------------------------------------------------------------------------------
                                                                   *file_handle*
                                 `file_handle`
A typical convention when opening a file is to use assert according to
sources. On failure, nil and the error message is supplied to `assert`. On
success `io.open` returns a file handle (stream) and assert returns it. I
haven't read enough to know if this is a good convention outside of what
the book is telling me as of now.

------------------------------------------------------------------------------
                                                                 *file_contents*
                                `file_contents`
After we receive a handle we can read from or write to the stream through
using methods like `read` and `write`. We call them as methods using the
colon notation. Note in colon notation self is automatically passed.

------------------------------------------------------------------------------
First question, why does type(file) return `userdata`? That doesn't mean
much to me nor allows much usage. Is there a way to gather more
information on the type? Am I doing something wrong?

Usage ~
>lua
    print("type(file_handle): ", type(file_handle))
    file_handle:close()
<

Lua provides functions designed specifically for file objects. The most
common is `io.type()`. Another question now is what happens when I call
`io.type()` after it's been closed? What will it print?

Usage ~
>lua
    print("io.type(file_handle): ", io.type(file_handle))
    file_handle:close()
    print("io.type(file_handle): ", io.type(file_handle))
<
io.type(file_handle): 	file
io.type(file_handle): 	closed file

------------------------------------------------------------------------------
So when would I want to use io.type(f)? Is there a real world situation
where it might be useful?

- Ensuring a file handle is still opened prior to doing something

Usage ~
>lua
    if io.type(file_handle) == "file" then
        -- do something
    else
        error("File is already closed.")
    end
<

- Ensuring closed is not called on a already closed file handle

Usage ~
>lua
    local function safe_close(file_handle)
        if io.type(file_handle) == "file" then
            file_handle:close
        end
    end
<

- Ensuring a file handle argument to function is a file handle

Usage ~
>lua
    local function foo(file_handle)
        assert(io.type(file_handle) == "file", "Expected a file handle")
        -- do something
    end
<

- Ensuring that I can reopen a file safely unsure if it was closed

Usage ~
>lua
    local function reopen(file_handle, filename)
        if io.type(file_handle) ~= "file" then
            return io.open(filename, "r")
        else
            return file_handle
        end
    end
<

==============================================================================
------------------------------------------------------------------------------
A question that has popped up now is how can I get away with writing to the
standard output yet not specify any kind of stream? How does the following
just know or allow an implicit behavior?

Usage ~
>lua
    io.write("Hello World\n")
<

The I/O library offsers handles for the three predefined C streams being
standard input `io.stdin`, standard output `io.stdout` and standard error
`io.stderr`.

Reading through sources I hear the phrase "convenience functions" which is
calling `io.write`, `io.read` as is. Lua is using the default file handles
here where satndard input is mapped to `io.read` and standard output is
mapped to `io.write`.

It's not unreasonable, according to the book and other sources, to imply
precision and or clarity by explicitly calling the default handles as such.

Usage ~
>lua
    io.stdout:write("Hello World\n")
<

But why is it not unreasonable if this behavior is implicitly handles for
me? Why would I ever want to manually write it out. Afterall, isn't this
the entire point to providing such convenient functions?

- You may need to write to both a log file and to stdout. Conveying clarity
  and precision in this case ensures safe intention.

Usage ~
>lua
    local log = io.open("log.txt", "w")
    log:write("Preparing to execute task\n")
    io.stdout:write("10% complete\n")
    io.stdout:write("20% complete\n")
    log:write("Task completed\n")
    log:close()
<

- What if the standard output is redirected to a file? What if an embedded
  system (that is running a OS) overrides standard output in some way?
  Conveying clarity and precision in this case also ensures safe intention.

Usage ~
>lua
    local log = io.open("log.txt", "w")
    io.output(log)
    io.write("This goes to the log file\n")
    io.stdout:write("But this goes to stdout")
<

- It may be required that you need to write to several streams at once and
  by choosing to do so conveying clarity in both situations contributes to
  readability/consistency.

Usage ~
>lua
    io.stderr:write("this is an error\n")
    io.stdout:write("this is a mesasge\n")
<

 vim:tw=78:ts=8:noet:ft=help:norl: